<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自动化测试</title>
      <link href="/2021/11/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/11/02/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="POM设计理念"><a href="#POM设计理念" class="headerlink" title="POM设计理念"></a>POM设计理念</h2><p>自动化测试，是需要基于完整的一套体系来实现，设计模式是其中之一。设计模式：实现自动化测试框架中，一定会用到数据驱动。结合关键字驱动或者POM来实现设计模式</p><h3 id="HTTP和HTTPS协议的区别？"><a href="#HTTP和HTTPS协议的区别？" class="headerlink" title="HTTP和HTTPS协议的区别？"></a>HTTP和HTTPS协议的区别？</h3><ul><li>http时超文本传输协议，信息是明文传输的，https是具有安全性ssl加密的传输协议。</li><li>http协议和https协议的启动端口也不一样，一个是80一个是443.</li><li>http的连接很简单，是无状态的，https协议是由ssl+http协议构建的可进行加密、身份认证的网络协议，更加安全</li></ul><h3 id="常见的post提交数据的方式有哪些？"><a href="#常见的post提交数据的方式有哪些？" class="headerlink" title="常见的post提交数据的方式有哪些？"></a>常见的post提交数据的方式有哪些？</h3><p>主要有四种方式：四种方式取决于Content_Type这个请求头： </p><blockquote><ul><li>Content_Type:application/x-www-form-urlencoded   特点：数据报文是字典，相当于通过表单的方式提交数据，数据格式：a=1&amp;b=2&amp;3</li><li>Content_Type:multipart/form-data 特点：报文包含有文件上传。</li><li>Content_Type:application/json(text/plain,text/html …)   特点：报文都是字符串类型。</li><li>Content_Type:binary 特点：报文类型是以二进制的方式上传文件。</li></ul></blockquote><h3 id="常见的请求头以及他们的作用是什么？"><a href="#常见的请求头以及他们的作用是什么？" class="headerlink" title="常见的请求头以及他们的作用是什么？"></a>常见的请求头以及他们的作用是什么？</h3><p>Accept:客户端接收的数据格式。</p><p>X-Request-With:异步请求。ajax异步请求。</p><p>User-Agent:发送请求的客户端的类型。</p><p>Content_Type:请求的内容的报文格式。</p><p>Cookie:Cookie信息。</p><h3 id="Get和Post的区别？"><a href="#Get和Post的区别？" class="headerlink" title="Get和Post的区别？"></a>Get和Post的区别？</h3><p>Get和Post都可以向服务器提交数据，并且都会从服务器获取数据。区别在于：</p><ul><li>传送参数方式不同：get通过地址栏的方式传参数，post通过表单报文传参数</li><li>传参的长度不同：个体参数有长度限制，post没有</li><li>一般情况下，get是获取数据，比如查询，post提交数据，比如：增，删，改</li><li>get只发送一个tcp数据报文（包含请求头和data），post发送两个报文（请求头，返回100；data，返回200）</li></ul><h3 id="接口请求中常见的返回状态码？"><a href="#接口请求中常见的返回状态码？" class="headerlink" title="接口请求中常见的返回状态码？"></a>接口请求中常见的返回状态码？</h3><p>1xx 信息提示，服务器收到请求，需要请求者继续执行操作</p><p>2xx OK，请求成功</p><p>3xx 重定向，资源已经重新分配。（发送一个请求时，这个请求多次请求了服务器的多个资源）</p><p>4xx 客户端错误</p><p>5xx 服务器内部错误</p><h3 id="cookie-session-token有什么相同点和不同点？"><a href="#cookie-session-token有什么相同点和不同点？" class="headerlink" title="cookie,session,token有什么相同点和不同点？"></a>cookie,session,token有什么相同点和不同点？</h3><p>相同点：都是用户鉴权并且都是服务器生成的。</p><p>不同点：</p><p>cookie保存在客户端的浏览器上，cookie不安全，可以分析存在在本地的cookie进行cookie欺骗。</p><p>session保存在服务器的内存，默认时间30分钟，比cookie安全，缺点是当登录的用户越多，比较占用服务器资源。session一般生成一个sessionId（名字自定义）sessionId可以通过cookie传输。</p><p>taken存储在服务器的数据库里，通过一个接口或者通过登录获取，然后后续所有的接口都需要传token才可以请求成功。token也可以通过cookie传输。</p><h3 id="请问你们公司是如何做接口测试的？（接口测试流程，方案以及用例设计）"><a href="#请问你们公司是如何做接口测试的？（接口测试流程，方案以及用例设计）" class="headerlink" title="请问你们公司是如何做接口测试的？（接口测试流程，方案以及用例设计）"></a>请问你们公司是如何做接口测试的？（接口测试流程，方案以及用例设计）</h3><ol><li><p>获取接口文档，熟悉单接口以及链路接口（接口业务流程）业务，包括接口地址，鉴权方式，入参，出参，错误码等。</p></li><li><p>编写接口测试用例并且评审</p><p>正例：单接口返回成功场景，链路接口业务流程实现逻辑；</p><p>反例：鉴权异常：空，错误，过期。参数异常：空，异常类型，长度异常。错误码异常。其它异常：接口黑名单，接口调用次数限制，分页（少于0，0，中间页，最大页，超过最大页）。</p></li><li><p>使用接口测试工具或代码执行方式执行接口测试。</p><p>重要考虑以下情况：1）接口关联，接口参数加密，是否动态参数，接口参数是否签名，是否需要带请求头。</p></li><li><p>实现持续集成并输出接口测试报告电子邮件，有BUG提出bug。</p></li></ol><h3 id="没有接口文档，如何做接口测试："><a href="#没有接口文档，如何做接口测试：" class="headerlink" title="没有接口文档，如何做接口测试："></a>没有接口文档，如何做接口测试：</h3><p>方式一：可以使用Fiddler，Charles抓包工具抓取接口数据之后整理成接口文档，如果不清楚的字段，找时间集中找开发验证，然后在进行接口测试。</p><p>方式二：通过Jmeter的代理录制功能，先把接口请求录制下来形成接口文档，然后再逐一的进行接口测试。</p><h3 id="接口测试中，依赖登录状态的接口如何测试？"><a href="#接口测试中，依赖登录状态的接口如何测试？" class="headerlink" title="接口测试中，依赖登录状态的接口如何测试？"></a>接口测试中，依赖登录状态的接口如何测试？</h3><p>依赖登录的接口本质上是每次发送请求的时候需要带上cookie和session才能够发送成功。在请求时需要添加上cookie和session。当然：如果是通过Postman会自动去管理，如果是通过jmeter来测试需要增加cookie管理器组件。如果是通过代码来实现接口测试，那么需要生成session对象，然后通过session对象来发送请求。</p><h3 id="你平常做接口测试过程中发现过哪些bug"><a href="#你平常做接口测试过程中发现过哪些bug" class="headerlink" title="你平常做接口测试过程中发现过哪些bug?"></a>你平常做接口测试过程中发现过哪些bug?</h3><p>常规Bug：接口没有实现，没有按照接口文档返回结果，输入一些异常值（空值，特色字符），接口报错，没有返回合理的错误提示。如：购买商品接口，其中有价格参数，我去测试时把商品的价格改成负数，购买成功。如：测试修改商品信息接口，接口文档要求只有商家和超级管理员才有权限修改，我传入一个普通用户的ID或者是传入其他商家的ID，修改成功。</p><p>接口测试就是为了避免绕过前端验证，直接访问后端接口的BUG</p><h3 id="你在接口测试中是如何校验结果是否正确？"><a href="#你在接口测试中是如何校验结果是否正确？" class="headerlink" title="你在接口测试中是如何校验结果是否正确？"></a>你在接口测试中是如何校验结果是否正确？</h3><p>有两种需要校验：</p><ol><li>状态码校验，验证返回的状态码为200 </li><li>业务校验：错误码为0；当接口响应报文比较短，比较固定的情况下，校验完全一致；当接口响应的报文比较长，比较多的情况下，校验最核心的业务信息；当接口的响应报文为非常复杂的多层级XML或JSON格式，通过Xpath,JsonPath正则表达式的匹配方式获取最关键的业务节点，然后校验；查询数据库校验或者通过其他接口校验。</li></ol><h3 id="如何分析一个Bug是前端还是后端的？"><a href="#如何分析一个Bug是前端还是后端的？" class="headerlink" title="如何分析一个Bug是前端还是后端的？"></a>如何分析一个Bug是前端还是后端的？</h3><p>通过抓包工具抓包，然后查看请求报文，如果请求报文对比接口文档有问题，那么就是前端问题。</p><p>如果请求报文没有问题，那就看返回报文，返回的数据不对，那就是后端开发的问题。</p><h3 id="依赖于第三方数据的接口如何进行测试？"><a href="#依赖于第三方数据的接口如何进行测试？" class="headerlink" title="依赖于第三方数据的接口如何进行测试？"></a>依赖于第三方数据的接口如何进行测试？</h3><p>接口关联是项目中的接口依赖于本项目的接口。可以通过Postman搭建Mock服务，但是Postman的mock服务有访问次数限制，一天只能访问1000次，也可以通过Seevlet,Flask等技术来实现接口Mock服务。</p><h3 id="对于加密接口，签名接口如何进行测试？"><a href="#对于加密接口，签名接口如何进行测试？" class="headerlink" title="对于加密接口，签名接口如何进行测试？"></a>对于加密接口，签名接口如何进行测试？</h3><p>加密接口：调用接口的时候，首先要清楚接口加密的方式是什么：</p><ol><li><p>对称式加密方式：不常用的有DES,AES，常用的Base64加密方式。</p></li><li><p>非对称加密方式：RSA加密。</p><p>由一个私钥秘密生成双钥（公钥和私钥），公钥加密，私钥解密，私钥加密，公钥解密。</p></li><li><p>只加密不解密。MD5加密，SHA1，SHA3</p></li><li><p>自定义加密规则，混合加密方式。</p></li></ol><p>了解加密规则之后，在请求接口之前先要对参数做对应的加密之后在发送请求。单一的加密方式，postman和jmeter有些是支持的，postman使用Javascript脚本实现，jmeter使用beanshell中的Java代码实现。</p><p>签名接口：了解签名规则后，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础</title>
      <link href="/2021/09/13/System/"/>
      <url>/2021/09/13/System/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h1><h2 id="操作系统基础-1"><a href="#操作系统基础-1" class="headerlink" title="操作系统基础"></a>操作系统基础</h2><ol><li>什么事操作系统？</li></ol><blockquote><ul><li>操作系统简称OS，是管理计算机硬件和软件资源的程序，是计算机的基石。</li><li>操作系统的本质是运行在计算机上的软件程序，用于管理计算机硬件和软件资源。例：运行在电脑的所以程序都是通过操作系统来调用系统内存以及磁盘等硬件资源。</li><li>操作系统屏蔽了硬件层的复杂性。</li><li>操作系统的内核(Kernel)是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。内核是连接应用程序和硬件的桥梁，决定系统的性能和稳定性。</li></ul></blockquote><ol start="2"><li>系统调用</li></ol><blockquote><p>根据进程访问的特点我们可以把进程在系统上的运行分为两个级别：</p><ol><li>用户态：用户运行的进程可以直接读取用户程序数据。</li><li>系统台：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><blockquote><p>我们运行的程序基本上都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？就需要系统调用了！</p><p>我们在运行用户程序中，凡是与系统态级别的资源有关的操作（文件管理、进程控制、内存管理等）都是必须通过系统调用的方式向操作系统提出服务请求，并由操作系统代为完成。</p><p>这些系统调用按功能大致可以分为以下类：</p><ul><li>设备管理：完成设备的请求或释放、以及设备启动等功能。</li><li>文件管理：完成文件的读、写、创建、删除等功能。</li><li>进程控制：完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信：完成进程之间的消息传递或信号传递等功能。</li><li>内存管理：完成内存的分配、回收以及获取作业占用内存大小及地址等功能。</li></ul></blockquote></blockquote><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><ol><li>进程与线程的区别</li></ol><p>一个进程中可以有多个线程，多个线程可以共享进程的堆和元空间资源，但是每个线程可以有自己的程序计数器、本地方法栈和虚拟机栈。</p><blockquote><p>线程是进程划分成的更小的运行单位，一个进程在执行过程中可以产生多个线程。线程和进程最大的不同在于基本上个进程都是独立的，而个线程则不一定，因为同一个进程的线程极有可能会相互影响，线程执行开销小，但不利于资源的管理和保护；进程则刚好相反。</p></blockquote><ol start="2"><li>进程的几种状态</li></ol><p>进程大致分为5种状态：</p><ul><li>创建状态(new)：进程正在被创建，尚未到就绪状态。</li><li>就绪状态(ready)：进程已处于准备运行的状态，即进程获得了除了处理器之外的一切所需要资源，一旦得到处理器资源（处理器分配时间片）即可运行。</li><li>运行状态(running)：进程正在处理器上运行。</li><li>阻塞状态(waiting)：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待IO操作完成。</li><li>结束状态(terminated)：进程正在从系统中消失。</li></ul><h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>应用层(application-layer) 的任务是通过进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议有很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。我们把应用层交互的数据单元称为报文。</p><blockquote><p>我们能直接接触的就是应用层，手机或者电脑使用的软件都是在应用层实现，当两个不同设备的应用需要通信的时候，应用就把数据传给下一层，也就输传输层。所以应用层只需要专注为用户提供应用功能，而不用关心数据是如何传输的。就类似于寄快递，我们只需要将包裹交给快递员，他负责运输。而且应用层是工作在操作系统的用户态，传输层及以下是工作在内核态。</p></blockquote><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><blockquote><p>域名系统(Domain Name System缩写DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的Web网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、cisco/">www.oracle.com、Cisco</a> 公司的域名是 <a href="http://www.cisco.com/">www.cisco.com</a> 等。</p></blockquote><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote><h2 id="运输层（传输层）"><a href="#运输层（传输层）" class="headerlink" title="运输层（传输层）"></a>运输层（传输层）</h2><p><strong>运输层(transport layer)的主要任务是负责向两台主机的进程之间的通信提供通用的数据传输服务。</strong> 应用层的数据包会传给传输层，传输层是为应用层提供网络支持的。传输层会有两个传输协议，分别是TCP和UDP。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</p><blockquote><p><strong>TCP全称传输控制协议(Transmission Control Protocol)</strong>,大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。TCP相比UDP多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能够可靠的传输给对方。</p></blockquote><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）</p><blockquote><p>只负责发送数据包，不保证数据是否能够抵达对方，当它实时性相对更好，传输效率也高。当然，UDP也可以实现可靠传输，把TCP的特性在应用层上实现就可以，不过要实现一个商用的可靠的UDP传输协议，也不是一件简单的事情。</p></blockquote><p>阿孙兴吃vbb</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收</title>
      <link href="/2021/09/10/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2021/09/10/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java垃圾回收"><a href="#Java垃圾回收" class="headerlink" title="Java垃圾回收"></a>Java垃圾回收</h1><h2 id="Java内存分配与回收"><a href="#Java内存分配与回收" class="headerlink" title="Java内存分配与回收"></a>Java内存分配与回收</h2><p>Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java自动内存管理最核心的功能是堆内存中对象的分配与回收。</p><p>Java堆是垃圾收集器管理的主要区域，因此也被称为GC堆（Garbagr Collected Heap)，从垃圾回收的角度，犹豫现在收集器基本都采用分类垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有Eden空间、From Survivor、To Survivor空间等。进一步划分的目的是更好的回收内存，或者更快的分配内存。</p><p><strong>堆空间的基本结构：</strong></p><p><img src="https://gitee.com/bixbycell/article-images/raw/master/article/20210910113122.png" alt="堆空间的基本结构："></p><p><code> Eden 区、From Survivor0(&quot;From&quot;) 区、To Survivor1(&quot;To&quot;) 区都属于新生代，Old Memory 区属于老年代。</code></p><p>一般情况下，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入S0或者S1，并且对象的年龄还会加1（Eden区-&gt;Survivor区后对象的年龄变为1），当它的年龄增加的一定程度（默认大小为15岁），就会被晋升到老年代中，对象晋升到老年代的年龄阀值，可以通过XX:MaxTenuringThreshold来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过XX:_PrintTenuringDistribution来打印出当次GC后的Threshold。</p><blockquote><p><strong>修正：</strong>==“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    uint age = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">        <span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">        total += sizes[age];</span><br><span class="line">        <span class="keyword">if</span> (total &gt; desired_survivor_size) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        age++;</span><br><span class="line">    &#125;</span><br><span class="line">    uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>经过这次GC后，Eden区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次GC前的“From”，新的”From”就是上次GC前的”To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，在这个过程中，有可能当次Minor GC后，Survivor的”From”区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>final, static, this, super关键字</title>
      <link href="/2021/08/23/interview/"/>
      <url>/2021/08/23/interview/</url>
      
        <content type="html"><![CDATA[<h1 id="final-static-this-super关键字"><a href="#final-static-this-super关键字" class="headerlink" title="final, static, this, super关键字"></a>final, static, this, super关键字</h1><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><blockquote><p>final关键字,修饰的类、方法、变量是不可变的（不可修改）：</p><ul><li>final修饰的类无法被继承，类中的所有成员方法都会隐式的指定为final类型；</li><li>final修饰的方法不能被重写；</li><li>final修饰的变量是常量，如果是基本数据类型的变量，则数据一旦在初始化之后被不能被更改，如果是引用类型的变量，则在对其初始化之后便不能在指向另外一个对象。</li></ul></blockquote><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><blockquote><ul><li><strong>修饰成员变量和成员方法：</strong>被static修饰的成员属于类，不属于单个这个类的对象，被类中所有对象共享，可以并且建议通过类名的方式调用。被static声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。调用格式：<code>类名.静态变量名  类名.静态方法名()</code></li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li><strong>静态导包(用来导入类中的静态资源，1.5 之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ul></blockquote><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><blockquote><p>this关键字用于引用当前实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    Employees[] employees;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalEmp = <span class="keyword">this</span>.employees.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;Total employees: &quot;</span> + totalEmp);</span><br><span class="line">        <span class="keyword">this</span>.report();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>this.employees.length:访问类的Manager的当前实例变量</li><li>this.report():调用类Manger的当前实例的方法</li></ul></blockquote><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><blockquote><p>super关键字用于从子类访问副类的变量和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">showNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.number = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">super</span>.showNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sub类访问父类成员变量number并调用其父类Super的<code>showNumber（）</code> 方法。</p></blockquote><h2 id="super和this注意事项"><a href="#super和this注意事项" class="headerlink" title="super和this注意事项"></a>super和this注意事项</h2><blockquote><ul><li>在构造器中使用<code>super()</code>调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this调用本类中的其他构造方法时，也要放在首行。</li><li>this、super不能用在static方法中。</li><li><code> 被static修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而this代表对本类对象的引用，指向本类对象；而super代表对父类对象的引用，指向父类对象；所以， **this 和 super 是属于对象范畴的东西，而静态方法是属于类范畴的东西**。</code></li></ul></blockquote><h1 id="并发多线程"><a href="#并发多线程" class="headerlink" title="并发多线程"></a>并发多线程</h1><h2 id="synchronized和Reentrantlock"><a href="#synchronized和Reentrantlock" class="headerlink" title="synchronized和Reentrantlock"></a>synchronized和Reentrantlock</h2><h3 id="ReebtrantLock比synchronized增加了一些高级功能"><a href="#ReebtrantLock比synchronized增加了一些高级功能" class="headerlink" title="ReebtrantLock比synchronized增加了一些高级功能"></a>ReebtrantLock比synchronized增加了一些高级功能</h3><blockquote><p>synchronized是依赖于JVM实现的，在JDK1.6之后对锁进行了大量的优化，（偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁的操作开销）这些优化都是在虚拟机层面实现的，并没有暴露给我们。</p><p>ReentrantLock是JDK层面实现的（也就是API层面，需要lock()方法配合try/finally语句快来完成）。</p><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><blockquote><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p></blockquote></blockquote><h2 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h2><ul><li>原子性：一个的操作或者多次操作，要么全部都得到执行并且不会受到任何其他因素的干扰而中断，要么所有操作都执行，要么都不执行。synchronized保证了代码片段的原子性。</li><li>可见性：当一变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。volatile保证了共享变量的可见性。</li><li>有序性：代码在执行过程中的先后顺序，Java在编译器以及运行期间的优化，代码的执行顺序未必是编写代码的时候的顺序。volatile可以禁止指令进行重新排序优化。</li></ul><h2 id="synchronized关键字和volatile关键字的区别"><a href="#synchronized关键字和volatile关键字的区别" class="headerlink" title="synchronized关键字和volatile关键字的区别"></a>synchronized关键字和volatile关键字的区别</h2><blockquote><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p><ul><li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile </code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li><li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li><li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul></blockquote><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>封装：</strong>明确表示出允许外部使用的所有成员函数和数据项，内部细节对外部调用透明，外部调用无需修改或者关心内部实现；</p><p><strong>继承：</strong>继承基类的方法，并做出自己的改变和扩展；</p><p><strong>多态：</strong>基于对象所属类的不同，外部对同一方法的调用，实际执行的逻辑不同。 </p><h2 id="JDK-JRE-JVM"><a href="#JDK-JRE-JVM" class="headerlink" title="JDK JRE JVM"></a>JDK JRE JVM</h2><p>JDK:Java Development Kit Java开发工具；</p><p>JRE:Java Runtime Environment Java运行时环境；</p><p>JVM:Java Virtual Machine Java虚拟机。</p><p><img src="https://gitee.com/bixbycell/article-images/raw/master/article/20211025101014.png" alt="Java图"></p><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><ul><li>抽象类可以有普通的成员函数，而接口中只能存在public abstract。</li><li>抽象类的成员变量可以是各种类型，而接口的成员变量只能是public static final类型的。</li><li>抽象类只能继承一个，接口可以实现多个</li></ul><blockquote><ul><li>抽象类设计的目的是代码复用，即不同的类具有某些相同的行为时，可以将这些类的相同行为派生出一个抽象类，抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。</li><li>接口是对行为的抽象，核心是定义行为，即子类可以做什么</li><li>使用场景：当你需要关注一个事物的本质时，用抽象类；当你需要关注一个事物的操作时，使用接口实现。</li></ul></blockquote><h2 id="List与Set区别"><a href="#List与Set区别" class="headerlink" title="List与Set区别"></a>List与Set区别</h2><ul><li>List:有序，按照对象进入的顺序保存对象，可重复，允许多个 元素对象，可以使用Iterator遍历取出所有元素，也可以使用for与get(index)的形式取出所有元素。</li><li>Set: 无序，不可重复，最多只能存在一个null的元素，同样可以使用Iterator遍历所有的元素。</li></ul><h2 id="ArrayList与LinkedList区别"><a href="#ArrayList与LinkedList区别" class="headerlink" title="ArrayList与LinkedList区别"></a>ArrayList与LinkedList区别</h2><ul><li>ArrayList:基于动态数组，连续内存存储，适合下标访问(随机访问)，扩容机制:数组长度固定，超出长度存数据时需要新建数组，然后将旧数组的数据拷贝到新数组中，如果不是尾部插入数据还会涉及到元素移动，使用尾部插入法并制定初始容量可以极大的提高性能、甚至超过LinkedList(需要大量的创建node对象)。</li><li>LinkedList:基于链表，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询:需要遍历，LinkedList遍历需要使用iterator不能使用for循环，每次for循环中通过get(index)取出元素是都需要对List重新遍历，性能消耗极大。使用indexOf返回元素索引时当结果为空时会遍历整个列表。</li></ul><h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><ul><li><p>HashMap是非线程安全的，可以存储null的key和value，但null作为键只能有一个，null作为值可以有多个。</p></li><li><p>HashTable使用synchronized修饰，是线程安全的，HashTable不允许有 null键和null值，否则会抛出NullPointerException</p><blockquote><p>效率：因为线程安全的问题，HashMap要比HashTable效率高一点。另外，HashTable基本被淘汰，不要在代码中使用它（如果你要保证线程安全的话就使用ConcurrentHashMap吧！）。</p></blockquote></li></ul><h2 id="如何实现一个IOC容器"><a href="#如何实现一个IOC容器" class="headerlink" title="如何实现一个IOC容器"></a>如何实现一个IOC容器</h2><p>1、配置文件配置包扫描路径</p><p>2、递归包扫描获取.classwenjian</p><p>3、反射、确定需要交给IOC管理的类</p><p>4、对需要注入的类进行以来注入</p><blockquote><ul><li>配置文件中指定需要扫描的包路径</li><li>定义一些注解，分别表示访问控制层、业务服务层、数据持久层、依赖注入注解、获取配置文件注释</li><li>从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个Set集合中进行存储</li><li>遍历这个Set集合，获取在类上有指定注解的类，并将其交给IOC容器，定义一个安全的MAP用来存储这些对象</li><li>遍历这个IOC容器，获取每一个类的实例，判断里面是有有依赖其他的类的实例，然后进行递归注入</li></ul></blockquote><h2 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h2><p>JDK自带有三个类加载器：bootstrap ClassLoader、ExtClassLoader、AppClassLoader。</p><p>BootStrapClassLoader是ExtClassLoader的类加载，默认负责加载%JAVA_HOME%/lib下的jar包和class文件。</p><p>ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹下的jar包和class类。</p><p>AppClassLoader是自定义类加载器的父类，负责加载classpath下的类文件。继承classLoader实现自定义类加载器。 </p><h2 id="并发的三大特性"><a href="#并发的三大特性" class="headerlink" title="并发的三大特性"></a>并发的三大特性</h2><ul><li>原子性：一个操作要么全部执行，要么都不执行（如银行转账操作）Synchronized</li><li>可见性：一个线程改变变量的值时，其他现场立即可见 Volatitle</li><li>有序性：代码在执行的过程中的先后顺序，Java在编译器以及运行期间的优化，代码的执行顺序未必是编写代码时候的顺序 Volatitle</li></ul><h2 id="为什么使用线程池，解释线程池的参数"><a href="#为什么使用线程池，解释线程池的参数" class="headerlink" title="为什么使用线程池，解释线程池的参数"></a>为什么使用线程池，解释线程池的参数</h2><ul><li><p>降低资源消耗；提高线程利用率，降低创建和销毁线程的消耗。</p></li><li><p>提高响应速度；任务来了，直接有线程可用可执行，而不是先创建线程再执行。</p></li><li><p>提高线程的可管理性；线程时稀缺资源，使用线程池可用统一分配调优监控。</p><blockquote><ul><li>corePoolSize代表核心线程数，也就是正常情况下创建工作的线程数，这些线程创建之后不会被消除，而是一种常驻线程</li><li>maxinumpoolSize代表最大的线程数，它与核心线程数相对应，表示最大允许被创建的线程数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，此时就会创建新的线程，但是线程池内线程总数不会超过最大线程数</li><li>keepAliveTime、unit表示超出核心线程数之外的线程的空闲存活时间，也就是核心线程不会消除，但是超出核心线程数的部分线程如果空闲一定时间则会被消除，我们可以通过setKeepAliveTime来设置空闲时间</li><li>workQueue用来存放待执行的任务，假设我们现在核心线程都已经被使用，还有任务进来则全部放入队列，直到整个队列被放满但任务还再持续进入则会开始创建新的线程</li><li>ThreadFactory实际上是一个线程工厂，用来生产线程执行任务。我们可以选择使用默认的创建工厂，产生的线程都在一个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择自定义线程工厂。</li><li>Handler任务拒绝策略，有两种情况，第一种是当我们调用shutdown等方法关闭线程池后，这时候即使线程池内部还有没有执行完的任务在执行，但是线程池已经关闭，我们再继续向线程池提交任务就会遭到拒绝。另一种情况就是当达到最大线程数，线程池已经没有能力继续处理提交的新任务时，这时也是拒绝。</li></ul></blockquote></li></ul><h2 id="线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？"><a href="#线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？" class="headerlink" title="线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？"></a>线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？</h2><ul><li>一般的队列只能保证作为一个有限长度的缓存区，如果超出缓冲长度，就无法保留当前的任务，阻塞队列通过阻塞可以保留住当前想要继续入队的任务。</li><li>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使其线程进入wait状态，释放cpu资源</li><li>阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程池利用阻塞队列的take方法挂起，从而维持核心线程的存活，不至于一直占用cpu资源</li><li>在创建新线程的时候，是需要获取全局锁的，这个时候其他的就得阻塞，影响了整体效率</li></ul><h2 id="线程池中线程复用原理"><a href="#线程池中线程复用原理" class="headerlink" title="线程池中线程复用原理"></a>线程池中线程复用原理</h2><p>线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱之前通过Thread创建线程时的一个线程必须对应一个任务的限制。在线程池中，同一个线程可以从阻塞队列中不断获取新任务来执行，其核心原理在于线程池对Thread进行了封装，并不是每次执行任务都会调用Thread.start()来创建新线程，而是让每一个线程去执行一个“循环任务”，在这个“循环任务”中不停检查是否有任务需要执行，如果有则直接执行，也就是有则直接调用任务中的run()方法，将run方法当成一个普通的方法执行，通过这种方式只使用固定的线程就将所有任务的run方法串联起来。</p><h2 id="Spring支持的bean的作用域"><a href="#Spring支持的bean的作用域" class="headerlink" title="Spring支持的bean的作用域"></a>Spring支持的bean的作用域</h2><ul><li>Singleton:单例</li><li>Prototype:每次注入都产生一个新对象</li><li>Request:每一个HTTP请求都产生一个实例</li><li>Session:每一个HTTP请求都会产生一个新的bean</li><li>Global-session:全局作用域</li></ul><h2 id="Spring中都用到了那些设计模式"><a href="#Spring中都用到了那些设计模式" class="headerlink" title="Spring中都用到了那些设计模式"></a>Spring中都用到了那些设计模式</h2><ul><li>简单工厂：由一个工厂类根据传入的参数，动态决定应该创建那个产品类。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获取bean对象，但是是否传入参数后创建还是传入参数前创建这个要根据具体情况来定</li><li>工厂方法：实现一个FactoryBean接口的bean是一类叫做factory的bean，其特点是spring会根据使用getBean()调用获得该bean时会自动调用该bean的getObject()方法，所以返回的都不是factory这个bean，而是这个bean.getObject()方法的返回值</li><li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。Spring对单例的实现：Spring中的单例模式完成了后半句话，即提供了全局的访问BeanFactory但没有从构造器级别去控制单例，这时因为Spring管理的是任意的Java对象</li><li>适配器模式：Spring定义了一个适配接口，使得每一个Controller有一种对应的适配器实现类，让适配器代替Controller执行相应的方法，这样在扩展controller时，只需要增加一个适配器就完成了SpringMVC的扩展，HandlerAdapter</li><li>装饰器模式：动态的给一个对象增加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更加灵活。带wrapper</li><li>动态代理：切面在应用运行时刻被注入，一般情况下在注入切面时，AOP容器会为目标对象创建动态的一个代理对象</li><li>观察者模式：Spring的事件驱动模型使用的是观察者模式，Spring对Observer模式常用的地方是listener的实现。</li><li>策略模式：Spring框架的资源访问Resource接口</li></ul><blockquote><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul></blockquote><h2 id="Spring-Boot、Spring-MVC和Spring有什么区别"><a href="#Spring-Boot、Spring-MVC和Spring有什么区别" class="headerlink" title="Spring Boot、Spring MVC和Spring有什么区别"></a>Spring Boot、Spring MVC和Spring有什么区别</h2><blockquote><p>spring是一个IOC容器，用来管理Bean，使用依赖注入实现控制反转，可以很方便的整合各种框架，提供AOP机制弥补OOP的代码重复问题、更方便将不同类不同方法中的共同处理抽取成切面、自动注入给方法执行，比如日志、异常等。</p><p>springmvc是spring对Web框架的一个解决方案，提供一个总的前控制器Servlet，用来接收请求，然后定义了一套路由策略（URL到handle的映射）及适配执行handle，将handle结果使用视图展现给前端。</p><p>Spring Boot是一个Spring提供的快速开发工具包，让程序员能更方便、快速的开发Spring+springMVC应用，简化了配置（约定了默认配置），整合了一系列的解决方案（starter机制）、redias、mongodb、es、可以开箱即用</p></blockquote><h2 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h2><ol><li>用户发送请求到前端控制器DispathcherServlet.</li><li>DispathcherServlet收到请求调用HandlerMapping处理映射器。</li><li>处理器映射器找到具体的处理器（根据XML配置、注解进行查找），生成处理器及处理器拦截器（如果有则生成）一并返回给DispathcherServlet。</li><li>DispathcherServlet调用HandlerAdapter处理器适配器。</li><li>HandlerAdapter经过适配调用具体的处理器（Controller，也叫后端控制器）。</li><li>Controller执行完成返回ModelAndView。</li><li>HandlerAdapter将Controller执行结果ModelAndView返回给DispathcherServlet。</li><li>DispathcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View。</li><li>DispathcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispathcherServlet响应用户。</li></ol><blockquote><ol><li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li><li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li><li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol></blockquote><h2 id="Spring-Boot自动装配"><a href="#Spring-Boot自动装配" class="headerlink" title="Spring Boot自动装配"></a>Spring Boot自动装配</h2><blockquote><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p><p><strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p></blockquote><blockquote><p>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p></blockquote><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h2 id="spring事务机制"><a href="#spring事务机制" class="headerlink" title="spring事务机制"></a>spring事务机制</h2><ol><li>Spring事务底层是基于数据库事务和AOP机制的</li><li>首先对于使用了@Transactional注解的Bean，spring会创建一个代理对象作为bean</li><li>当调用代理对象的方法时，会判断方法上是否加了@Transactional注解</li><li>如果加了，那么利用事务管理器创建一个数据库连接</li><li>并且修改数据库连接的autocommit属性为false，禁止此连接自动提交</li><li>然后执行当前方法，方法会执行sql</li><li>执行完当前方法后，如果没有出现异常就直接提交事务</li><li>如果出现异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</li><li>Spring的隔离级别就是数据库的隔离级别</li></ol><h2 id="redis应用场景"><a href="#redis应用场景" class="headerlink" title="redis应用场景"></a>redis应用场景</h2><ol><li>5大value类型：String、Hash、List、Set、SortedSet</li><li>基本上就是缓存～！</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/29/hello-world/"/>
      <url>/2021/07/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java架构Study</title>
      <link href="/2021/07/26/study01/"/>
      <url>/2021/07/26/study01/</url>
      
        <content type="html"><![CDATA[<h1 id="Java架构Study-01"><a href="#Java架构Study-01" class="headerlink" title="Java架构Study-01"></a>Java架构Study-01</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="事务传播-Propagation"><a href="#事务传播-Propagation" class="headerlink" title="事务传播 - Propagation"></a>事务传播 - Propagation</h2><blockquote><p>REQUIRED: 使用当前的事务，如果当前没有事务，则自己新建一个事务，子方法是必须运行在一个事务中的；</p><p>​          如果当前存在事务，则加入这个事务，成为一个整体。</p><p>​          举例：领导没饭吃，我有钱，我会自己买了自己吃；领导有的吃，会分给你一起吃。</p><p>SUPPORTS: 如果当前有事务，则使用事务；如果当前没有事务，则不使用事务。</p><p>​         举例：领导没饭吃，我也没饭吃；领导有饭吃，我也有饭吃。</p><p>MANDATORY: 该传播属性强制必须存在一个事务，如果不存在，则抛出异常。</p><p>​          举例：领导必须管饭，不管饭没饭吃，我就不乐意了，就不干了（抛出异常）。</p><p>REQUIRES_NEW: 如果当前有事务，则挂起该事务，并且自己创建一个新的事务给自己使用；</p><p>​             如果当前没有事务，则同 REQUIRED。</p><p>​             举例：领导有饭吃，我偏不要，我自己买了自己吃。</p><p>NOT_SUPPORTED: 如果当前有事务，则把事务挂起，自己不适用事务去运行数据库操作。</p><p>​              举例：领导有饭吃，分一点给你，我太忙了，放一边，我不吃。</p><p>NEVER: 如果当前有事务存在，则抛出异常。</p><p>​      举例：领导有饭给你吃，我不想吃，我热爱工作，我抛出异常。</p><p>NESTED: 如果当前有事务，则开启子事务（嵌套事务），嵌套事务是独立提交或者回滚；</p><p>​       如果当前没有事务，则同 REQUIRED。</p><p>​       但是如果主事务提交，则会携带子事务一起提交。</p><p>​       如果主事务回滚，则子事务会一起回滚。相反，子事务异常，则父事务可以回滚或不回滚。</p><p>​       举例：领导决策不对，老板怪罪，领导带着小弟一同受罪。小弟出了差错，领导可以推卸责任。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shiro权限基本使用</title>
      <link href="/2021/07/13/shiro/"/>
      <url>/2021/07/13/shiro/</url>
      
        <content type="html"><![CDATA[<h1 id="shiro权限基本使用"><a href="#shiro权限基本使用" class="headerlink" title="shiro权限基本使用"></a>shiro权限基本使用</h1><h2 id="什么是shiro"><a href="#什么是shiro" class="headerlink" title="什么是shiro"></a>什么是shiro</h2><blockquote><p><strong>Apache Shiro™</strong> is a powerful and easy-to-use Java security framework that performs authentication, authorization, cryptography, and session management. With Shiro’s easy-to-understand API, you can quickly and easily secure any application – from the smallest mobile applications to the largest web and enterprise applications.</p><p><code>Shiro</code>是一个功能强大且易于使用的Java安全框架，它执行身份验证、授权、加密和会话管理。使用Shiro易于理解的API，您可以快速轻松地保护任何应用程序—从最小的移动应用程序到最大的web和企业应用程序。</p></blockquote><h2 id="shiro核心架构"><a href="#shiro核心架构" class="headerlink" title="shiro核心架构"></a>shiro核心架构</h2><p><a href="https://shiro.apache.org/">shiro参考文档</a></p><p><img src="https://gitee.com/bixbycell/article-images/raw/master/article/20210722214631.png" alt="Detailed Architecture"></p><h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><blockquote><p><code>Subject</code>即主体，外部应用于Subject进行交互，subject记录了当前的操作用户，将用户的概念理解为当前操作的主体。外部程序通过subject进行授权认证，而subject是通过SecurityManger安全管理器进行授权认证。</p></blockquote><h3 id="SecurityManger"><a href="#SecurityManger" class="headerlink" title="SecurityManger"></a>SecurityManger</h3><blockquote><p><code>SecurityManager</code>即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。</p><p><strong><code>SecurityManager</code>是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口。</strong></p></blockquote><h3 id="Authenticator"><a href="#Authenticator" class="headerlink" title="Authenticator"></a>Authenticator</h3><blockquote><p><code>Authenticator</code>即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本可以满足大多数需求，也可以自定义认证器。</p></blockquote><h3 id="Authorizer"><a href="#Authorizer" class="headerlink" title="Authorizer"></a>Authorizer</h3><blockquote><p><code>Authorizer</code>即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。</p></blockquote><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><blockquote><p><code>Realm</code>即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。</p><p><strong>不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码</strong></p></blockquote><h3 id="SessionManager"><a href="#SessionManager" class="headerlink" title="SessionManager"></a>SessionManager</h3><blockquote><p><code>sessionManager</code>即会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录。</p></blockquote><h3 id="SessionDAO"><a href="#SessionDAO" class="headerlink" title="SessionDAO"></a>SessionDAO</h3><blockquote><p><code>SessionDAO</code>即会话dao，是对session会话操作的一套接口，比如要将session存储到数据库，可以通过jdbc将会话存储到数据库。</p></blockquote><h3 id="CacheManager"><a href="#CacheManager" class="headerlink" title="CacheManager"></a>CacheManager</h3><blockquote><p><code>CacheManager</code>即缓存管理，将用户权限数据存储在缓存，这样可以提高性能。</p></blockquote><h3 id="Cryptography"><a href="#Cryptography" class="headerlink" title="Cryptography"></a>Cryptography</h3><blockquote><p><code>Cryptography</code>即密码管理，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能。</p></blockquote><h2 id="Shiro中的认证"><a href="#Shiro中的认证" class="headerlink" title="Shiro中的认证"></a>Shiro中的认证</h2><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><blockquote><p>身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。</p></blockquote><h3 id="shiro中认证的关键对象"><a href="#shiro中认证的关键对象" class="headerlink" title="shiro中认证的关键对象"></a>shiro中认证的关键对象</h3><ul><li><p><code>Subject:主体</code></p><blockquote><p>访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体。</p></blockquote></li><li><p><code>Principal:身份信息</code></p><blockquote><p>是主体（subject）进行身份认证的标识，标识必须具有<code>唯一性</code>，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。</p></blockquote></li><li><p><code>Credential:凭证信息</code></p><blockquote><p>凭证信息，是只有主体自己知道的安全信息，如密码、证书等。</p></blockquote></li></ul><h3 id="认证实现"><a href="#认证实现" class="headerlink" title="认证实现"></a>认证实现</h3><h4 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h4><hr><p><img src="https://gitee.com/bixbycell/article-images/raw/master/article/20210722214651.png"></p><blockquote><p>如上图，我们通过Shiro架构图的认证部分，来说明Shiro认证内部的处理顺序：<br>1、应用程序构建了一个终端用户认证信息的AuthenticationToken 实例后，调用Subject.login方法。<br>2、Sbuject的实例通常是DelegatingSubject类（或子类）的实例对象，在认证开始时，会委托应用程序设置的securityManager实例调用securityManager.login(token)方法。<br>3、SecurityManager接受到token(令牌)信息后会委托内置的Authenticator的实例（通常都是ModularRealmAuthenticator类的实例）调用authenticator.authenticate(token). ModularRealmAuthenticator在认证过程中会对设置的一个或多个Realm实例进行适配，它实际上为Shiro提供了一个可拔插的认证机制。<br>4、如果在应用程序中配置了多个Realm，ModularRealmAuthenticator会根据配置的AuthenticationStrategy(认证策略)来进行多Realm的认证过程。在Realm被调用后，AuthenticationStrategy将对每一个Realm的结果作出响应。<br>注：如果应用程序中仅配置了一个Realm，Realm将被直接调用而无需再配置认证策略。<br>5、判断每一个Realm是否支持提交的token，如果支持，Realm将调用getAuthenticationInfo(token); getAuthenticationInfo 方法就是实际认证处理，我们通过覆盖Realm的doGetAuthenticationInfo方法来编写我们自定义的认证处理。</p></blockquote><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><ul><li>maven依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建.ini配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 约定写法</span><br><span class="line">[users]</span><br><span class="line"># 用户名=密码</span><br><span class="line">bixby=123</span><br><span class="line">zzy=123456</span><br></pre></td></tr></table></figure><blockquote><p>.ini文件主要用来学习shiro时书写需要的权限数据，从而免去配置数据库数据的步骤。</p></blockquote><ul><li>测试代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建安全管理器对象</span></span><br><span class="line">        DefaultSecurityManager securityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        <span class="comment">//给安全管理器设置realm</span></span><br><span class="line">        securityManager.setRealm(<span class="keyword">new</span> IniRealm(<span class="string">&quot;classpath:shiro.ini&quot;</span>));</span><br><span class="line">        <span class="comment">//给全局安全工具类SecurityUtils设置安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//拿到当前的subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//创建令牌</span></span><br><span class="line">        AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;bixby&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用户认证</span></span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功，欢迎您：&quot;</span> + token.getPrincipal());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败，用户不存在！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败，密码不正确&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码追踪"><a href="#源码追踪" class="headerlink" title="源码追踪"></a>源码追踪</h3><blockquote><p>从<code>subject.login(token)</code>入口开始debug,最终可以得到用户的认证是在<code>SimpleAccountRealm</code>的<code>doGetAuthenticationInfo</code>的方法中完成，而<code>SimpleAccountRealm</code>继承自<code>AuthorizingRealm</code>，而<code>AuthorizingRealm</code>中有一个抽象方法</p><p><strong>protected abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection var1);</strong></p><p><code>SimpleAccountRealm</code>就是复写了<code>AuthorizingRealm</code>中的这个抽象方法实现的用户认证，所以后面我们需要自定义认证的时候我们就可以自定义一个realm继承自<code>AuthorizingRealm</code>来复写<code>doGetAuthorizationInfo</code>，在这个方法里面实现我们自己的认证逻辑</p><p>不仅认证，有意思的是<code>AuthorizingRealm</code>是继承自<code>AuthenticatingRealm</code>，而<code>AuthenticatingRealm</code>中有个抽象方法</p><p><strong>protected abstract AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken var1) throws AuthenticationException;</strong></p><p>这个方法是实现用户授权的方法,也就是说通过我们自定义realm继承<code>AuthorizingRealm</code>就可以同时复写认证和授权两个方法</p></blockquote><h2 id="shiro自定义Relam实现认证"><a href="#shiro自定义Relam实现认证" class="headerlink" title="shiro自定义Relam实现认证"></a>shiro自定义Relam实现认证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bixby</span></span><br><span class="line"><span class="comment"> * 使用自定义relam</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRealmAuthenticator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建安全管理器对象</span></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        <span class="comment">//给安全管理器设置realm</span></span><br><span class="line">        defaultSecurityManager.setRealm(<span class="keyword">new</span> CustomerRealm());</span><br><span class="line">        <span class="comment">//给全局安全工具类SecurityUtils设置安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        <span class="comment">//拿到当前的subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//创建令牌</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;bixby&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用户认证</span></span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功，欢迎您：&quot;</span> + token.getPrincipal());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败，用户不存在！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败，密码不正确&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Bixby</span></span><br><span class="line"><span class="comment"> * 自定义realm实现，将认证/授权数据的来源转为数据库的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//在token中获取用户名</span></span><br><span class="line">        String principal = (String) authenticationToken.getPrincipal();</span><br><span class="line">        System.out.println(principal);</span><br><span class="line">        <span class="comment">//根据用户信息查询数据库中的相关数据</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bixby&quot;</span>.equals(principal))&#123;</span><br><span class="line">            <span class="comment">//参数: 用户名，密码，当前realm的名字</span></span><br><span class="line">            SimpleAuthenticationInfo simpleAuthenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(<span class="string">&quot;bixby&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="keyword">this</span>.getName());</span><br><span class="line">            <span class="keyword">return</span> simpleAuthenticationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shiro的加密和随机盐"><a href="#Shiro的加密和随机盐" class="headerlink" title="Shiro的加密和随机盐"></a>Shiro的加密和随机盐</h2><h3 id="Shiro中密码的加密策略"><a href="#Shiro中密码的加密策略" class="headerlink" title="Shiro中密码的加密策略"></a>Shiro中密码的加密策略</h3><blockquote><p>实际应用中用户的密码并不是明文存储在数据库中的，而是采用一种加密算法将密码加密后存储在数据库中。Shiro中提供了一整套的加密算法，并且提供了随机盐。shiro使用指定的加密算法将用户密码和随机盐进行加密，并按照指定的散列次数将散列后的密码存储在数据库中。由于随机盐每个用户可以不同，这就极大的提高了密码的安全性。</p></blockquote><h3 id="Shiro中的加密方式"><a href="#Shiro中的加密方式" class="headerlink" title="Shiro中的加密方式"></a>Shiro中的加密方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroMD5Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Md5Hash md5Hash01 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(md5Hash01.toHex());</span><br><span class="line">        </span><br><span class="line">        Md5Hash md5Hash02 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;bixby&quot;</span>);</span><br><span class="line">        System.out.println(md5Hash02.toHex());</span><br><span class="line"></span><br><span class="line">        Md5Hash md5Hash03 = <span class="keyword">new</span> Md5Hash(<span class="string">&quot;123456&quot;</span>,<span class="string">&quot;bixby&quot;</span>,<span class="number">1024</span>);</span><br><span class="line">        System.out.println(md5Hash03.toHex());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shiro中自定义加密Realm"><a href="#Shiro中自定义加密Realm" class="headerlink" title="Shiro中自定义加密Realm"></a>Shiro中自定义加密Realm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerMD5AuthenticatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建SecurityManager</span></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        <span class="comment">// 设置自定义realm</span></span><br><span class="line">        CustomerMD5Realm realm = <span class="keyword">new</span> CustomerMD5Realm();</span><br><span class="line">        <span class="comment">// 为realm设置凭证匹配器</span></span><br><span class="line">        HashedCredentialsMatcher credentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        <span class="comment">// 设置加密算法</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置hash次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">        realm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        defaultSecurityManager.setRealm(realm);</span><br><span class="line">        <span class="comment">// 设置安全工具类</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        <span class="comment">// 通过安全工具类获取subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 创建token</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;bixby&quot;</span>,<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用户认证</span></span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功，欢迎您：&quot;</span> + token.getPrincipal());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败，用户不存在！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败，密码不正确&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerMD5Realm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String principal = (String) authenticationToken.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bixby&quot;</span>.equals(principal))&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 用户名</span></span><br><span class="line"><span class="comment">             * 加密后的密码</span></span><br><span class="line"><span class="comment">             * 随机盐</span></span><br><span class="line"><span class="comment">             * 当前realm的名称</span></span><br><span class="line"><span class="comment">             * 4b0265506f38a38498893cfa5ab1b7ac是密码和盐加密后的结果</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(principal,</span><br><span class="line">                    <span class="string">&quot;4b0265506f38a38498893cfa5ab1b7ac&quot;</span>,</span><br><span class="line">                    ByteSource.Util.bytes(<span class="string">&quot;bixby&quot;</span>),</span><br><span class="line">                    <span class="keyword">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Shiro中的授权"><a href="#Shiro中的授权" class="headerlink" title="Shiro中的授权"></a>Shiro中的授权</h2><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><blockquote><p>授权，即访问控制，控制谁能访问那些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。</p><p>授权可以理解为Who对What(Which)进行How操作：</p><p><code>Who，即主体（Subject）</code>，主体需要访问系统中的资源。</p><p><code>What，即资源（Resource)</code>，如系统菜单、页面、按钮、类方法、系统商品信息等。资源包括<code>资源类型</code>和<code>资源实例</code>，比如<code>商品信息为资源类型</code>，类型为t01的商品为<code>资源实例</code>，编号为001的商品信息也属于<code>资源实例</code>。</p><p><code>How，权限/许可（Permission)</code>，规定了主体对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个类方法的调用权限、编号为001用户的修改权限等，通过权限可知主体对哪些资源都有哪些操作许可。</p></blockquote><h3 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h3><ul><li><h3 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h3></li></ul><blockquote><p>RBAC基于角色的访问控制（Role-Based Access Control）是以角色为中心进行访问控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">if</span>(subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">  <span class="comment">//操作什么资源</span></span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li><h3 id="基于资源的访问控制"><a href="#基于资源的访问控制" class="headerlink" title="基于资源的访问控制"></a>基于资源的访问控制</h3></li></ul><blockquote><p>RBAC基于资源的访问控制（Resource-Based Access Control）是以资源为中心进行访问控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(subject.isPermission(<span class="string">&quot;user:update:01&quot;</span>))&#123; <span class="comment">//资源实例</span></span><br><span class="line">  <span class="comment">//对01用户进行修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(subject.isPermission(<span class="string">&quot;user:update:*&quot;</span>))&#123;  <span class="comment">//资源类型</span></span><br><span class="line">  <span class="comment">//对01用户进行修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="权限字符串"><a href="#权限字符串" class="headerlink" title="权限字符串"></a>权限字符串</h3><blockquote><p>权限字符串的规则是：<strong>资源标识符：操作：资源实例标识符</strong>，意思是对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用*通配符。</p><p>例子：</p><ul><li>用户创建权限：user:create，或user:create:*</li><li>用户修改实例001的权限：user:update:001</li><li>用户实例001的所有权限：user:*：001</li></ul></blockquote><h3 id="权限的编码方式"><a href="#权限的编码方式" class="headerlink" title="权限的编码方式"></a>权限的编码方式</h3><ul><li><h3 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line"><span class="comment">//有权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//无权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="注解式"><a href="#注解式" class="headerlink" title="注解式"></a>注解式</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresRoles(&quot;admin&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//有权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="标签式"><a href="#标签式" class="headerlink" title="标签式"></a>标签式</h3></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSP/GSP 标签：在JSP/GSP 页面通过相应的标签完成：</span><br><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line">&lt;!— 有权限—&gt;</span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br><span class="line">注意: Thymeleaf 中使用shiro需要额外集成!</span><br></pre></td></tr></table></figure><h3 id="授权的实现"><a href="#授权的实现" class="headerlink" title="授权的实现"></a>授权的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerMD5AuthenticatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建SecurityManager</span></span><br><span class="line">        DefaultSecurityManager defaultSecurityManager = <span class="keyword">new</span> DefaultSecurityManager();</span><br><span class="line">        <span class="comment">// 设置自定义realm</span></span><br><span class="line">        CustomerMD5Realm realm = <span class="keyword">new</span> CustomerMD5Realm();</span><br><span class="line">        <span class="comment">// 为realm设置凭证匹配器</span></span><br><span class="line">        HashedCredentialsMatcher credentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        <span class="comment">// 设置加密算法</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置hash次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">        realm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">        defaultSecurityManager.setRealm(realm);</span><br><span class="line">        <span class="comment">// 设置安全工具类</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        <span class="comment">// 通过安全工具类获取subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 创建token</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;bixby&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用户认证</span></span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            subject.login(token);</span><br><span class="line">            System.out.println(<span class="string">&quot;认证状态：&quot;</span> + subject.isAuthenticated());</span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功，欢迎您：&quot;</span> + token.getPrincipal());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败，用户不存在！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败，密码不正确&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//授权</span></span><br><span class="line">        <span class="keyword">if</span> (subject.isAuthenticated())&#123;</span><br><span class="line">            <span class="comment">//基于角色权限控制</span></span><br><span class="line">            System.out.println(subject.hasRole(<span class="string">&quot;super&quot;</span>));</span><br><span class="line">            <span class="comment">//基于多角色权限控制(同时具有)</span></span><br><span class="line">            subject.hasAllRoles(Arrays.asList(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;super&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//是否具有其中一个角色</span></span><br><span class="line">            <span class="keyword">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;super&quot;</span>,<span class="string">&quot;user&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">boolean</span> boolean01:booleans)&#123;</span><br><span class="line">                System.out.println(boolean01);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于权限字符串的访问控制  资源标识符:操作:资源类型</span></span><br><span class="line">            System.out.println(<span class="string">&quot;权限:&quot;</span>+subject.isPermitted(<span class="string">&quot;user:update:01&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;权限:&quot;</span>+subject.isPermitted(<span class="string">&quot;product:create:02&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分别具有那些权限</span></span><br><span class="line">            <span class="keyword">boolean</span>[] permitted = subject.isPermitted(<span class="string">&quot;user:*:01&quot;</span>, <span class="string">&quot;order:*:10&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">boolean</span> b : permitted) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同时具有哪些权限</span></span><br><span class="line">            <span class="keyword">boolean</span> permittedAll = subject.isPermittedAll(<span class="string">&quot;user:*:01&quot;</span>, <span class="string">&quot;product:create:01&quot;</span>);</span><br><span class="line">            System.out.println(permittedAll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerMD5Realm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从系统返回的身份信息集合中获取主身份信息（用户名）</span></span><br><span class="line">        String primaryPrincipal = (String) principalCollection.getPrimaryPrincipal();</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名: &quot;</span>+primaryPrincipal);</span><br><span class="line">        <span class="comment">//根据用户名获取当前用户的角色信息,以及权限信息</span></span><br><span class="line">        SimpleAuthorizationInfo simpleAuthorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据库中查询角色信息赋值给权限对象</span></span><br><span class="line">        simpleAuthorizationInfo.addRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        simpleAuthorizationInfo.addRole(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据库中查询权限信息赋值个权限对象</span></span><br><span class="line">        simpleAuthorizationInfo.addStringPermission(<span class="string">&quot;user:*:01&quot;</span>);</span><br><span class="line">        simpleAuthorizationInfo.addStringPermission(<span class="string">&quot;product:create&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String principal = (String) authenticationToken.getPrincipal();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bixby&quot;</span>.equals(principal))&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 用户名</span></span><br><span class="line"><span class="comment">             * 加密后的密码</span></span><br><span class="line"><span class="comment">             * 随机盐</span></span><br><span class="line"><span class="comment">             * 当前realm的名称</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(principal,</span><br><span class="line">                    <span class="string">&quot;4b0265506f38a38498893cfa5ab1b7ac&quot;</span>,</span><br><span class="line">                    ByteSource.Util.bytes(<span class="string">&quot;bixby&quot;</span>),</span><br><span class="line">                    <span class="keyword">this</span>.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
